\documentclass[a4paper]{article}
\usepackage[a4paper,left=3cm,right=2cm,top=2.5cm,bottom=2.5cm]{geometry}
\usepackage{palatino}
\usepackage[colorlinks=true,linkcolor=blue,citecolor=blue]{hyperref}
\usepackage{graphicx}
\usepackage{cp2122t}
\usepackage{subcaption}
\usepackage{adjustbox}
\usepackage{color}

\definecolor{red}{RGB}{255,  0,  0}
\definecolor{blue}{RGB}{0,0,255}
\def\red{\color{red}}
\def\blue{\color{blue}}
%================= local x=====================================================%
\def\getGif#1{\includegraphics[width=0.3\textwidth]{cp2122t_media/#1.png}}
\let\uk=\emph
\def\aspas#1{``#1"}
%================= lhs2tex=====================================================%
%% ODER: format ==         = "\mathrel{==}"
%% ODER: format /=         = "\neq "
%
%
\makeatletter
\@ifundefined{lhs2tex.lhs2tex.sty.read}%
  {\@namedef{lhs2tex.lhs2tex.sty.read}{}%
   \newcommand\SkipToFmtEnd{}%
   \newcommand\EndFmtInput{}%
   \long\def\SkipToFmtEnd#1\EndFmtInput{}%
  }\SkipToFmtEnd

\newcommand\ReadOnlyOnce[1]{\@ifundefined{#1}{\@namedef{#1}{}}\SkipToFmtEnd}
\usepackage{amstext}
\usepackage{amssymb}
\usepackage{stmaryrd}
\DeclareFontFamily{OT1}{cmtex}{}
\DeclareFontShape{OT1}{cmtex}{m}{n}
  {<5><6><7><8>cmtex8
   <9>cmtex9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmtex10}{}
\DeclareFontShape{OT1}{cmtex}{m}{it}
  {<-> ssub * cmtt/m/it}{}
\newcommand{\texfamily}{\fontfamily{cmtex}\selectfont}
\DeclareFontShape{OT1}{cmtt}{bx}{n}
  {<5><6><7><8>cmtt8
   <9>cmbtt9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmbtt10}{}
\DeclareFontShape{OT1}{cmtex}{bx}{n}
  {<-> ssub * cmtt/bx/n}{}
\newcommand{\tex}[1]{\text{\texfamily#1}}	% NEU

\newcommand{\Sp}{\hskip.33334em\relax}


\newcommand{\Conid}[1]{\mathit{#1}}
\newcommand{\Varid}[1]{\mathit{#1}}
\newcommand{\anonymous}{\kern0.06em \vbox{\hrule\@width.5em}}
\newcommand{\plus}{\mathbin{+\!\!\!+}}
\newcommand{\bind}{\mathbin{>\!\!\!>\mkern-6.7mu=}}
\newcommand{\rbind}{\mathbin{=\mkern-6.7mu<\!\!\!<}}% suggested by Neil Mitchell
\newcommand{\sequ}{\mathbin{>\!\!\!>}}
\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}
\usepackage{polytable}

%mathindent has to be defined
\@ifundefined{mathindent}%
  {\newdimen\mathindent\mathindent\leftmargini}%
  {}%

\def\resethooks{%
  \global\let\SaveRestoreHook\empty
  \global\let\ColumnHook\empty}
\newcommand*{\savecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\savecolumns[#1]}}
\newcommand*{\restorecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\restorecolumns[#1]}}
\newcommand*{\aligncolumn}[2]%
  {\g@addto@macro\ColumnHook{\column{#1}{#2}}}

\resethooks

\newcommand{\onelinecommentchars}{\quad-{}- }
\newcommand{\commentbeginchars}{\enskip\{-}
\newcommand{\commentendchars}{-\}\enskip}

\newcommand{\visiblecomments}{%
  \let\onelinecomment=\onelinecommentchars
  \let\commentbegin=\commentbeginchars
  \let\commentend=\commentendchars}

\newcommand{\invisiblecomments}{%
  \let\onelinecomment=\empty
  \let\commentbegin=\empty
  \let\commentend=\empty}

\visiblecomments

\newlength{\blanklineskip}
\setlength{\blanklineskip}{0.66084ex}

\newcommand{\hsindent}[1]{\quad}% default is fixed indentation
\let\hspre\empty
\let\hspost\empty
\newcommand{\NB}{\textbf{NB}}
\newcommand{\Todo}[1]{$\langle$\textbf{To do:}~#1$\rangle$}

\EndFmtInput
\makeatother
%
%
%
%
%
%
% This package provides two environments suitable to take the place
% of hscode, called "plainhscode" and "arrayhscode". 
%
% The plain environment surrounds each code block by vertical space,
% and it uses \abovedisplayskip and \belowdisplayskip to get spacing
% similar to formulas. Note that if these dimensions are changed,
% the spacing around displayed math formulas changes as well.
% All code is indented using \leftskip.
%
% Changed 19.08.2004 to reflect changes in colorcode. Should work with
% CodeGroup.sty.
%
\ReadOnlyOnce{polycode.fmt}%
\makeatletter

\newcommand{\hsnewpar}[1]%
  {{\parskip=0pt\parindent=0pt\par\vskip #1\noindent}}

% can be used, for instance, to redefine the code size, by setting the
% command to \small or something alike
\newcommand{\hscodestyle}{}

% The command \sethscode can be used to switch the code formatting
% behaviour by mapping the hscode environment in the subst directive
% to a new LaTeX environment.

\newcommand{\sethscode}[1]%
  {\expandafter\let\expandafter\hscode\csname #1\endcsname
   \expandafter\let\expandafter\endhscode\csname end#1\endcsname}

% "compatibility" mode restores the non-polycode.fmt layout.

\newenvironment{compathscode}%
  {\par\noindent
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed\)%
   \par\noindent
   \ignorespacesafterend}

\newcommand{\compaths}{\sethscode{compathscode}}

% "plain" mode is the proposed default.
% It should now work with \centering.
% This required some changes. The old version
% is still available for reference as oldplainhscode.

\newenvironment{plainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newenvironment{oldplainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

% Here, we make plainhscode the default environment.

\newcommand{\plainhs}{\sethscode{plainhscode}}
\newcommand{\oldplainhs}{\sethscode{oldplainhscode}}
\plainhs

% The arrayhscode is like plain, but makes use of polytable's
% parray environment which disallows page breaks in code blocks.

\newenvironment{arrayhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\parray}%
  {\endparray\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newcommand{\arrayhs}{\sethscode{arrayhscode}}

% The mathhscode environment also makes use of polytable's parray 
% environment. It is supposed to be used only inside math mode 
% (I used it to typeset the type rules in my thesis).

\newenvironment{mathhscode}%
  {\parray}{\endparray}

\newcommand{\mathhs}{\sethscode{mathhscode}}

% texths is similar to mathhs, but works in text mode.

\newenvironment{texthscode}%
  {\(\parray}{\endparray\)}

\newcommand{\texths}{\sethscode{texthscode}}

% The framed environment places code in a framed box.

\def\codeframewidth{\arrayrulewidth}
\RequirePackage{calc}

\newenvironment{framedhscode}%
  {\parskip=\abovedisplayskip\par\noindent
   \hscodestyle
   \arrayrulewidth=\codeframewidth
   \tabular{@{}|p{\linewidth-2\arraycolsep-2\arrayrulewidth-2pt}|@{}}%
   \hline\framedhslinecorrect\\{-1.5ex}%
   \let\endoflinesave=\\
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \framedhslinecorrect\endoflinesave{.5ex}\hline
   \endtabular
   \parskip=\belowdisplayskip\par\noindent
   \ignorespacesafterend}

\newcommand{\framedhslinecorrect}[2]%
  {#1[#2]}

\newcommand{\framedhs}{\sethscode{framedhscode}}

% The inlinehscode environment is an experimental environment
% that can be used to typeset displayed code inline.

\newenvironment{inlinehscode}%
  {\(\def\column##1##2{}%
   \let\>\undefined\let\<\undefined\let\\\undefined
   \newcommand\>[1][]{}\newcommand\<[1][]{}\newcommand\\[1][]{}%
   \def\fromto##1##2##3{##3}%
   \def\nextline{}}{\) }%

\newcommand{\inlinehs}{\sethscode{inlinehscode}}

% The joincode environment is a separate environment that
% can be used to surround and thereby connect multiple code
% blocks.

\newenvironment{joincode}%
  {\let\orighscode=\hscode
   \let\origendhscode=\endhscode
   \def\endhscode{\def\hscode{\endgroup\def\@currenvir{hscode}\\}\begingroup}
   %\let\SaveRestoreHook=\empty
   %\let\ColumnHook=\empty
   %\let\resethooks=\empty
   \orighscode\def\hscode{\endgroup\def\@currenvir{hscode}}}%
  {\origendhscode
   \global\let\hscode=\orighscode
   \global\let\endhscode=\origendhscode}%

\makeatother
\EndFmtInput
%
\def\ana#1{\mathopen{[\!(}#1\mathclose{)\!]}}
%%format (bin (n) (k)) = "\Big(\vcenter{\xymatrix@R=1pt{" n "\\" k "}}\Big)"
%%format % = "\mathbin{/}"
\newlabel{eq:fokkinga}{{3.93}{110}{The mutual-recursion law}{section.3.17}{}}
\def\plus{\mathbin{\dagger}}

%---------------------------------------------------------------------------

\title{
          Cálculo de Programas
\\
          Trabalho Prático
\\
          LCC --- 2021/22 (2º semestre)
}

\author{
          \dium
\\
          Universidade do Minho
}


\date\mydate

\makeindex
\newcommand{\rn}[1]{\textcolor{red}{#1}}
\begin{document}

\maketitle

\begin{center}\large
\begin{tabular}{ll}
\textbf{Grupo} nr. & 53
\\\hline
a94956 & André Lucena Ribas Ferreira
\\
a96936 & Carlos Eduardo Da Silva Machado
\\
a97485 & Gonçalo Manuel Maia de Sousa
\end{tabular}
\end{center}

\section{Preâmbulo}

\CP\ tem como objectivo principal ensinar
a progra\-mação de computadores como uma disciplina científica. Para isso,
baseia-se num repertório de \emph{combinadores} que formam uma álgebra da
programação (conjunto de leis universais e seus corolários) e usa esses
combinadores para construir programas \emph{composicionalmente}, isto é,
agregando programas já existentes.

Na sequência pedagógica dos planos de estudo dos cursos que têm
esta disciplina, opta-se pela aplicação deste método à programação
em \Haskell\ (sem prejuízo da sua aplicação a outras linguagens
funcionais). Assim, o presente trabalho prático coloca os
alunos perante problemas concretos que deverão ser implementados em
\Haskell.  Há ainda um outro objectivo: o de ensinar a documentar
programas, a validá-los e a produzir textos técnico-científicos de
qualidade.

Antes de abodarem os problemas propostos no trabalho, os grupos devem ler
com atenção o anexo \ref{sec:documentacao} onde encontrarão as instruções
relativas ao sofware a instalar, etc.


\Problema

O algorítmo da \emph{divisão Euclidiana},
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{ed}\;(\Varid{n},\mathrm{0})\mathrel{=}\Conid{Nothing}{}\<[E]%
\\
\>[B]{}\Varid{ed}\;(\Varid{n},\Varid{d}\mathbin{+}\mathrm{1})\mathrel{=}(\Conid{Just}\comp \p1)\;(\Varid{aux}\;\Varid{d}\;\Varid{n}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
dá erro quando o denominador \ensuremath{\Varid{d}} é zero, recorrendo à função auxiliar seguinte
nos outros casos, paramétrica em \ensuremath{\Varid{d}}: 
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{aux}\;\Varid{d}\mathrel{=}\conj{\Varid{q}\;\Varid{d}}{\conj{\Varid{r}\;\Varid{d}}{\Varid{c}\;\Varid{d}}}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Esta, por sua vez, é o emparelhamento das seguintes funções mutuamente recursivas,
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{q}\;\Varid{d}\;\mathrm{0}\mathrel{=}\mathrm{0}{}\<[E]%
\\
\>[B]{}\Varid{q}\;\Varid{d}\;(\Varid{n}\mathbin{+}\mathrm{1})\mathrel{=}\Varid{q}\;\Varid{d}\;\Varid{n}\mathbin{+}(\mathbf{if}\;\Varid{x}\equiv \mathrm{0}\;\mathbf{then}\;\mathrm{1}\;\mathbf{else}\;\mathrm{0})\;\mathbf{where}\;\Varid{x}\mathrel{=}\Varid{c}\;\Varid{d}\;\Varid{n}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{r}\;\Varid{d}\;\mathrm{0}\mathrel{=}\mathrm{0}{}\<[E]%
\\
\>[B]{}\Varid{r}\;\Varid{d}\;(\Varid{n}\mathbin{+}\mathrm{1})\mathrel{=}\mathbf{if}\;\Varid{x}\equiv \mathrm{0}\;\mathbf{then}\;\mathrm{0}\;\mathbf{else}\;\mathrm{1}\mathbin{+}\Varid{r}\;\Varid{d}\;\Varid{n}\;\mathbf{where}\;\Varid{x}\mathrel{=}\Varid{c}\;\Varid{d}\;\Varid{n}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{c}\;\Varid{d}\;\mathrm{0}\mathrel{=}\Varid{d}{}\<[E]%
\\
\>[B]{}\Varid{c}\;\Varid{d}\;(\Varid{n}\mathbin{+}\mathrm{1})\mathrel{=}\mathbf{if}\;\Varid{x}\equiv \mathrm{0}\;\mathbf{then}\;\Varid{d}\;\mathbf{else}\;\Varid{x}\mathbin{-}\mathrm{1}\;\mathbf{where}\;\Varid{x}\mathrel{=}\Varid{c}\;\Varid{d}\;\Varid{n}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
onde \ensuremath{\Varid{q}} colabora na produção do quociente, \ensuremath{\Varid{r}} na produção do resto, e \ensuremath{\Varid{c}}
é uma função de controlo --- todas paramétricas no denominador \ensuremath{\Varid{d}}.

Mostre, por aplicação da lei de recursividade mútua, que \ensuremath{\Varid{aux}\;\Varid{d}} é a mesma
função que o ciclo-for seguinte:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{6}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{loop}\;\Varid{d}\mathrel{=}\for{(\Varid{g}\;\Varid{d})}\ {(\mathrm{0},(\mathrm{0},\Varid{d}))}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{6}{}\<[6]%
\>[6]{}\Varid{g}\;\Varid{d}\;(\Varid{q},(\Varid{r},\mathrm{0}))\mathrel{=}(\Varid{q}\mathbin{+}\mathrm{1},(\mathrm{0},\Varid{d})){}\<[E]%
\\
\>[B]{}\hsindent{6}{}\<[6]%
\>[6]{}\Varid{g}\;\Varid{d}\;(\Varid{q},(\Varid{r},\Varid{c}\mathbin{+}\mathrm{1}))\mathrel{=}(\Varid{q},(\Varid{r}\mathbin{+}\mathrm{1},\Varid{c})){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\textbf{Sugestão}: consultar o anexo \ref{sec:mr}.

\Problema

Considere o seguinte desafio, extraído de \href{http://bebras.dcc.fc.up.pt/problems/2020/problemas_09_10.pdf}{O Bebras - Castor Informático} (edição 2020):

\begin{quote}\em
\textbf{11 --- Robôs e Pedras Preciosas}
A Alice e o Bob estão a controlar um robô num labirinto com pedras preciosas.
O robô começa na localização indicada na figura abaixo [Fig.~\ref{fig:labirinto}].
O robô segue um caminho até encontrar uma bifurcação. Um dos jogadores decide
qual dos caminhos (esquerda ou direita) o robô deve tomar. Depois, o robô
segue esse caminho até encontrar outra bifurcação, e assim consecutivamente
(o robô nunca volta para trás no seu caminho).

A Alice e o Bob decidem à vez qual a direção a seguir, com a Alice a começar,
o Bob decidindo a 2ª bifurcação, a Alice a 3ª e por aí adiante. O jogo termina
quando o robô chegar ao final de um caminho sem saída, com o robô a recolher
todas as pedras preciosas que aí encontrar. A Alice quer que o robô acabe
o jogo com o maior número possível de pedras preciosas, enquanto que o Bob
quer que o robô acabe o jogo com o menor número possível de pedras preciosas.

A Alice e o Bob sabem que cada um vai tentar ser mais esperto que o outro.
Por isso se, por exemplo, o Bob redirecionar o robô para uma bifurcação onde
é possível recolher 3 ou 7 pedras preciosas, ele sabe que a Alice vai comandar
o robô escolhendo o caminho que leva às 7 pedras preciosas.
\end{quote}

O labirinto deste desafio (Fig.~\ref{fig:labirinto}) configura uma árvore
binária de tipo \LTree\ cujas folhas têm o número de pedras preciosas do
correspondente caminho:\footnote{Abstracção: as diferentes pedras preciosas
são irrelevantes, basta o seu número.}

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{8}{@{}>{\hspre}l<{\hspost}@{}}%
\column{10}{@{}>{\hspre}c<{\hspost}@{}}%
\column{10E}{@{}l@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{t}\mathrel{=}\Conid{Fork}\;({}\<[E]%
\\
\>[B]{}\hsindent{8}{}\<[8]%
\>[8]{}\Conid{Fork}\;({}\<[E]%
\\
\>[8]{}\hsindent{5}{}\<[13]%
\>[13]{}\Conid{Fork}\;(\Conid{Leaf}\;\mathrm{2},\Conid{Leaf}\;\mathrm{7}),{}\<[E]%
\\
\>[8]{}\hsindent{5}{}\<[13]%
\>[13]{}\Conid{Fork}\;(\Conid{Leaf}\;\mathrm{5},\Conid{Leaf}\;\mathrm{4})),{}\<[E]%
\\
\>[B]{}\hsindent{8}{}\<[8]%
\>[8]{}\Conid{Fork}\;({}\<[E]%
\\
\>[8]{}\hsindent{5}{}\<[13]%
\>[13]{}\Conid{Fork}\;(\Conid{Leaf}\;\mathrm{8},\Conid{Leaf}\;\mathrm{6}),{}\<[E]%
\\
\>[8]{}\hsindent{5}{}\<[13]%
\>[13]{}\Conid{Fork}\;(\Conid{Leaf}\;\mathrm{1},\Conid{Leaf}\;\mathrm{3})){}\<[E]%
\\
\>[8]{}\hsindent{2}{}\<[10]%
\>[10]{}){}\<[10E]%
\ColumnHook
\end{hscode}\resethooks

\begin{enumerate}
\item	
Defina como catamorfismo de \LTree's a função \ensuremath{\Varid{both}\mathbin{::}{\LTree}\;\Conid{Int}\to \Conid{Int}\times\Conid{Int}} tal que
\begin{quote}
\ensuremath{(\Varid{a},\Varid{b})\mathrel{=}\Varid{both}\;\Varid{t}}
\end{quote}
dê,
\begin{itemize}
\item	em \ensuremath{\Varid{a}}: o resultado mais favorável à Alice, quando esta é a primeira a jogar,
	tendo em conta as jogadas do Bob e as suas;
\item	em \ensuremath{\Varid{b}}: o resultado mais favorável ao Bob, quando este é o primeiro a jogar,
	tendo em conta as jogadas da Alice e as suas.
\end{itemize}
\item
De seguida, extraia (por recursividade mútua) as funções (recursivas) \ensuremath{\Varid{alice}} e \ensuremath{\Varid{bob}} tais que
\begin{eqnarray*}
	\ensuremath{\Varid{both}\mathrel{=}\conj{\Varid{alice}}{\Varid{bob}}}
\end{eqnarray*}
(Alternativamente, poderá codificar \ensuremath{\Varid{alice}} e \ensuremath{\Varid{bob}} em primeiro lugar e depois
juntá-las num catamorfismo recorrendo às leis da recursividade mútua.)
\end{enumerate}

\begin{figure}
	\centering
	\includegraphics[width=0.6\textwidth]{cp2122t_media/castor11.png}
\caption{
   Labirinto de ``Robôs e Pedras Preciosas".
   \label{fig:labirinto}
}
\end{figure}

\Problema

O \sierp{triângulo de Sierpinski} (Fig.~\ref{fig:sierp1}) é uma figura geométrica
\fractal\ em que um triângulo se subdivide recursivamente em sub-triângulos,
da seguinte forma: considere-se um triângulo rectângulo e
isósceles \ensuremath{\Conid{A}} cujos catetos têm comprimento \ensuremath{\Varid{s}}. A estrutura \fractal\ é
criada desenhando-se três triângulos no interior de \ensuremath{\Conid{A}}, todos eles
rectângulos e isósceles e com catetos de comprimento \ensuremath{\Varid{s}\div \mathrm{2}}. Este passo
é depois repetido para cada um dos triângulos desenhados e assim
sucessivamente (Fig.~\ref{fig:sierp2}).

\begin{figure}[htb]
\begin{center}
	\includegraphics[width=0.4\textwidth]{cp2122t_media/sierpinski1.png}
\end{center}
  \caption{Um triângulo de Sierpinski com profundidade \ensuremath{\mathrm{4}}.}
  \label{fig:sierp1}
\end{figure}

\begin{figure}[htb]
\begin{center}
	\includegraphics[width=0.6\textwidth]{cp2122t_media/sierpinski2.png}
\end{center}
  \caption{Construção de um triângulo de Sierpinski}
  \label{fig:sierp2}
\end{figure}

Um triângulo de Sierpinski é gerado repetindo-se infinitamente o processo
acima descrito; no entanto para efeitos de visualização é conveniente 
parar o processo recursivo a um determinado nível.

A figura a desenhar é constituída por triângulos todos da mesma dimensão
(por exemplo, no quarto triângulo da Fig.~\ref{fig:sierp2} desenharam-se
27 triângulos). Seja cada triângulo geometricamente descrito pelas coordenadas
do seu vértice inferior esquerdo e o comprimento dos seus catetos:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{type}\;\Conid{Tri}\mathrel{=}(\Conid{Point},\Conid{Side}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
onde
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{type}\;\Conid{Side}\mathrel{=}\Conid{Int}{}\<[E]%
\\
\>[B]{}\mathbf{type}\;\Conid{Point}\mathrel{=}(\Conid{Int},\Conid{Int}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

A estrutura recursiva que suporta a criação de \sierp{triângulos de Sierpinski}
é captada por uma árvore ternária,
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\mathsf{LTree3}\;\Varid{a}\mathrel{=}\Conid{Tri}\;\Varid{a}\mid \Conid{Nodo}\;(\mathsf{LTree3}\;\Varid{a})\;(\mathsf{LTree3}\;\Varid{a})\;(\mathsf{LTree3}\;\Varid{a})\;\mathbf{deriving}\;(\Conid{Eq},\Conid{Show}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
em cujas folhas se irão encontrar os triângulos mais pequenos, todos da
mesma dimensão, que deverão ser desenhados. Apenas estes conterão informação
de carácter geométrico, tendo os nós da árvore um papel exclusivamente estrutural.
Portanto, a informação geométrica guardada em cada folha consiste nas coordenadas
do vértice inferior esquerdo e no cateto do respectivo triângulo. A função
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{sierpinski}\mathbin{::}(\Conid{Tri},\Conid{Int})\to [\mskip1.5mu \Conid{Tri}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{sierpinski}\mathrel{=}\Varid{folhasSierp}\comp \Varid{geraSierp}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
recebe a informação do triângulo exterior e a profundidade pretendida,
que funciona como critério de paragem do processo de construção do fractal.
O seu resultado é a lista de triângulos a desenhar.

Esta função é um hilomorfismo do tipo \ensuremath{\mathsf{LTree3}}, i.e.\ a composição de
duas funções: uma que gera \ensuremath{\mathsf{LTree3}}s,
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{geraSierp}\mathbin{::}(\Conid{Tri},\Conid{Int})\to \mathsf{LTree3}\;\Conid{Tri}{}\<[E]%
\\
\>[B]{}\Varid{geraSierp}\mathrel{=}\Varid{anaLTree3}\;g_2 {}\<[E]%
\ColumnHook
\end{hscode}\resethooks
e outra que as consome:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{folhasSierp}\mathbin{::}\mathsf{LTree3}\;\Conid{Tri}\to [\mskip1.5mu \Conid{Tri}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{folhasSierp}\mathrel{=}\Varid{cataLTree3}\;g_1 {}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Trabalho a realizar:
\begin{enumerate}
\item Desenvolver a biblioteca \emph{pointfree} para o tipo \ensuremath{\mathsf{LTree3}} de forma análoga
      a outras bibliotecas que conhece (\eg\ \BTree, \LTree, etc).
\item Definir os genes \ensuremath{g_1 } e \ensuremath{g_2 } do hilomorfismo \ensuremath{\Varid{sierpinski}}.
\item Correr
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{teste}\mathrel{=}\Varid{desenha}\;(\Varid{sierpinski}\;(\Varid{base},\mathrm{3})){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
para verificar a correcta geração de triângulos de Sierpinski em \svg\footnote{\svg,
abreviatura de \emph{Scalable Vector Graphics}, é um dialecto de \xml\ para
computação gráfica. A biblioteca Svg.hs (fornecida) faz uma interface rudimentar
entre \Haskell\ e \svg.}, onde \ensuremath{\Varid{desenha}} é uma função dada no anexo \ref{sec:codigo} que,
para o argumento \ensuremath{\Varid{sierpinski}\;(\Varid{base},\mathrm{3})}, deverá produzir o triângulo colorido da 
Fig.~\ref{fig:sierp1}.\footnote{O resultado é gravado no ficheiro \text{\ttfamily \char95{}\char46{}html}, que pode 
ser visualizado num browser. Poderão ser feitos testes com outros níveis de produndidade.}
\end{enumerate}

\Problema

Os computadores digitais baseiam-se na representação Booleana da informação,
isto é, sob a forma de \emph{bits} que podem ter dois valores, vulg.\ \ensuremath{\mathrm{0}} e \ensuremath{\mathrm{1}}.
Um problema muito frequente é o de os bits se alterarem, devido a ruído ao
nível electrónico. Essas alterações espúrias designam-se \emph{bit-flips}
e podem acontecer a qualquer nível: na transmissão de informação, na gravação
em disco, etc, etc.

Em contraste com essas perturbações, o utilizador de serviços informáticos
raramente dá pela sua presença. Porquê? Porque existe muito trabalho teórico
em correcção dos erros gerados por \emph{bit-flips}, que os permite esconder
do utilizador.

O objectivo desta questão é conseguirmos avaliar experimentalmente o funcionamento
de uma dessas técnicas de correcção de erros, a mais elementar de todas,
chamada \emph{código de repetição}, escrevendo tão pouco código (\Haskell)
quanto possível. Para isso vamos recorrer ao mónade das \emph{distribuições
probabilísticas} (detalhes no apêndice \ref{sec:probabilities}).

Vamos supor que queremos medir a eficácia de um tal código na situação seguinte:
queremos transmitir mensagens que constam exclusivamente de letras maiúsculas,
representadas por 5 bits cada uma segundo o esquema seguinte de codificação,
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{enc}\mathbin{::}\Conid{Char}\to \Conid{Bin}{}\<[E]%
\\
\>[B]{}\Varid{enc}\;\Varid{c}\mathrel{=}\Varid{tobin}\;(\Varid{ord}\;\Varid{c}\mathbin{-}\Varid{ord}\;\text{\ttfamily 'A'}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
e descodificação,
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{dec}\mathbin{::}\Conid{Bin}\to \Conid{Char}{}\<[E]%
\\
\>[B]{}\Varid{dec}\;\Varid{b}\mathrel{=}\Varid{chr}\;(\Varid{frombin}\;\Varid{b}\mathbin{+}\Varid{ord}\;\text{\ttfamily 'A'}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
onde \ensuremath{\Varid{tobin}} e \ensuremath{\Varid{frombin}} são funções dadas no anexo \ref{sec:codigo}. Por exemplo,
\begin{quote}
\ensuremath{\Varid{enc}\;\text{\ttfamily 'A'}\mathrel{=}[\mskip1.5mu \mathrm{0},\mathrm{0},\mathrm{0},\mathrm{0},\mathrm{0}\mskip1.5mu]}
\\
\ensuremath{\Varid{enc}\;\text{\ttfamily 'B'}\mathrel{=}[\mskip1.5mu \mathrm{0},\mathrm{0},\mathrm{0},\mathrm{0},\mathrm{1}\mskip1.5mu]}
\\ $\vdots$ \\
\ensuremath{\Varid{enc}\;\text{\ttfamily 'Z'}\mathrel{=}[\mskip1.5mu \mathrm{1},\mathrm{1},\mathrm{0},\mathrm{0},\mathrm{1}\mskip1.5mu]}
\end{quote}
Embora \ensuremath{\Varid{dec}} e \ensuremath{\Varid{enc}} sejam inversas uma da outra, para o intervalo de \ensuremath{\text{\ttfamily 'A'}}
a \ensuremath{\text{\ttfamily 'Z'}}, deixam de o ser quando, a meio da transmissão, acontecem bit-flips: 

\begin{center}
\unitlength=0.08ex
\linethickness{0.1pt}
\begin{picture}(800.00,110.00)(-160,270)
\put(-170.00,310.00){\ensuremath{\Varid{x}}}
\put( 510.00,310.00){\ensuremath{\Varid{y}}$\not=$ \ensuremath{\Varid{x}}}
\put( 110.00,340.00){(bit-flips)}
\put(-100.00,270.00){\framebox(90,90)[cc]{\ensuremath{\Varid{enc}}}}
\put(350.00,270.00){\framebox(90,90)[cc]{\ensuremath{\Varid{dec}}}}
\put(-150.00,315.00){\vector(1,0){50.00}}
\put( -10.00,315.00){\vector(1,0){50.00}}
\multiput(100.00,315.00)(30,0){5}{.}
\put(300.00,315.00){\vector(1,0){50.00}}
\put(440.00,315.00){\vector(1,0){50.00}}
\end{picture}
\end{center}

Vejamos com quantificar "os estragos". Sabendo-se, por exemplo e por
observação estatística, que a probabilidade de um \ensuremath{\mathrm{0}} virar \ensuremath{\mathrm{1}} é de \ensuremath{\mathrm{4}\mathbin{\%}}
e a de \ensuremath{\mathrm{1}} virar \ensuremath{\mathrm{0}} é de \ensuremath{\mathrm{10}\mathbin{\%}}
\footnote{Estas probabilidades, na prática muito mais baixas, estão inflacionadas
para mais fácil observação.}, simula-se essa informação sobre a forma de
uma função probabilística, em Haskell:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{bflip}\mathbin{::}\Conid{Bit}\to \fun{Dist}\;\Conid{Bit}{}\<[E]%
\\
\>[B]{}\Varid{bflip}\;\mathrm{0}\mathrel{=}\Conid{D}\;[\mskip1.5mu (\mathrm{0},\mathrm{0.96}),(\mathrm{1},\mathrm{0.04})\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{bflip}\;\mathrm{1}\mathrel{=}\Conid{D}\;[\mskip1.5mu (\mathrm{1},\mathrm{0.90}),(\mathrm{0},\mathrm{0.10})\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Agora vamos simular o envio de caracteres. O que devia ser \ensuremath{\Varid{transmit}\mathrel{=}\Varid{dec}\comp \Varid{enc}}
vai ter agora que prever a existência de possíveis bit-flips no meio
da transmissão:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{transmit}\mathrel{=}\Varid{dec'}\comp \Varid{propagate}\;\Varid{bflip}\comp \Varid{enc}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Por exemplo, \ensuremath{\Varid{transmit}\;\text{\ttfamily 'H'}} irá dar a seguinte distribuição:
\begin{quote}\small
\begin{tabbing}\ttfamily
~~\char39{}H\char39{}~~67\char46{}2\char37{}\\
\ttfamily ~~\char39{}D\char39{}~~~7\char46{}5\char37{}\\
\ttfamily ~~\char39{}F\char39{}~~~7\char46{}5\char37{}\\
\ttfamily ~~\char39{}G\char39{}~~~7\char46{}5\char37{}\\
\ttfamily ~~\char39{}P\char39{}~~~2\char46{}8\char37{}\\
\ttfamily ~~\char39{}X\char39{}~~~2\char46{}8\char37{}\\
\ttfamily ~~\char39{}E\char39{}~~~0\char46{}8\char37{}\\
\ttfamily ~~\char39{}B\char39{}~~~0\char46{}8\char37{}\\
\ttfamily ~~\char39{}C\char39{}~~~0\char46{}8\char37{}\\
\ttfamily ~~\char39{}L\char39{}~~~0\char46{}3\char37{}\\
\ttfamily ~~\char39{}N\char39{}~~~0\char46{}3\char37{}\\
\ttfamily ~~\char39{}O\char39{}~~~0\char46{}3\char37{}\\
\ttfamily ~~\char39{}T\char39{}~~~0\char46{}3\char37{}\\
\ttfamily ~~\char39{}V\char39{}~~~0\char46{}3\char37{}\\
\ttfamily ~~\char39{}W\char39{}~~~0\char46{}3\char37{}\\
\ttfamily ~~\char39{}\char96{}\char39{}~~~0\char46{}1\char37{}\\
\ttfamily ~~\char39{}A\char39{}~~~0\char46{}1\char37{}
\end{tabbing}
\end{quote}
A saída 'H', que se esperava com \ensuremath{\mathrm{100}\mathbin{\%}} de certeza,
agora só ocorrerá, estatísticamente, com a probabilidade de \ensuremath{\mathrm{67.2}\mathbin{\%}},
consequência dos bit-flips, havendo um âmbito bastante
grande de respostas erradas, mas com probabilidades mais baixas.

\begin{enumerate}
\item \textbf{Trabalho a fazer:} completar a definição do catamorfismo de listas \ensuremath{\Varid{propagate}}.
\end{enumerate}

O que se pode fazer quanto a estes erros de transmissão? Os chamados códigos
de repetição enviam cada bit um número impar de vezes, tipicamente \ensuremath{\mathrm{3}} vezes.
Cada um desses três bits (que na origem são todos iguais) está sujeito
a bit-flips. O que se faz é \emph{votar} no mais frequente --- ver função \ensuremath{v_3 } no anexo.
Se agora a transmissão do \ensuremath{\text{\ttfamily 'H'}} for feita em triplicado,
usando
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{transmit3}\mathrel{=}\Varid{dec'}\comp \Varid{propagate3}\;\Varid{bflip3}\comp \Varid{enc}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
ter-se-á:
\begin{quote}\small
\begin{tabbing}\ttfamily
~Main\char62{}~transmit3~\char39{}H\char39{}\\
\ttfamily ~~\char39{}H\char39{}~~91\char46{}0\char37{}\\
\ttfamily ~~\char39{}F\char39{}~~~2\char46{}6\char37{}\\
\ttfamily ~~\char39{}G\char39{}~~~2\char46{}6\char37{}\\
\ttfamily ~~\char39{}D\char39{}~~~2\char46{}6\char37{}\\
\ttfamily ~~\char39{}P\char39{}~~~0\char46{}4\char37{}\\
\ttfamily ~~\char39{}X\char39{}~~~0\char46{}4\char37{}\\
\ttfamily ~~\char39{}B\char39{}~~~0\char46{}1\char37{}\\
\ttfamily ~~\char39{}C\char39{}~~~0\char46{}1\char37{}\\
\ttfamily ~~\char39{}E\char39{}~~~0\char46{}1\char37{}
\end{tabbing}
\end{quote}
Vê-se que a probabilidade da resposta certa aumentou muito, para \ensuremath{\mathrm{91}\mathbin{\%}},
com redução também do espectro de respostas erradas.

\begin{enumerate}
\setcounter{enumi}{1}
\item \textbf{Trabalho a fazer:} completar a definição do catamorfismo de
listas \ensuremath{\Varid{propagate3}} e da função \ensuremath{\Varid{bflip3}}.
\end{enumerate}

Apesar da sua eficácia, esta técnica de correcção de erros é dispendiosa,
obrigando o envio do triplo dos bits. Isso levou a
comunidade científica a encontrar formas mais sofisticadas para resolver
o mesmo problema sem tal ``overhead". Quem estiver interessado em saber mais
sobre este fascinante tópico poderá começar por visualizar este
\href{https://youtu.be/X8jsijhllIA?t=4}{vídeo} no YouTube.

\part*{Anexos}

\appendix

\section{Documentação para realizar o trabalho}
\label{sec:documentacao}
Para cumprir de forma integrada os objectivos do trabalho vamos recorrer
a uma técnica de programa\-ção dita ``\litp{literária}'' \cite{Kn92},
cujo princípio base é o seguinte:
%
\begin{quote}\em Um programa e a sua documentação devem coincidir.
\end{quote}
%
Por outras palavras, o código fonte e a documentação de um
programa deverão estar no mesmo ficheiro.

O ficheiro \texttt{cp2122t.pdf} que está a ler é já um exemplo de
\litp{programação literária}: foi gerado a partir do texto fonte
\texttt{cp2122t.lhs}\footnote{O sufixo `lhs' quer dizer
\emph{\lhaskell{literate Haskell}}.} que encontrará no
\MaterialPedagogico\ desta disciplina descompactando o ficheiro
\texttt{cp2122t.zip} e executando:
\begin{Verbatim}[fontsize=\small]
    $ lhs2TeX cp2122t.lhs > cp2122t.tex
    $ pdflatex cp2122t
\end{Verbatim}
em que \href{https://hackage.haskell.org/package/lhs2tex}{\texttt\LhsToTeX} é
um pre-processador que faz ``pretty printing''
de código Haskell em \Latex\ e que deve desde já instalar utilizando o
utiliário \href{https://www.haskell.org/cabal/}{cabal} disponível em \href{https://www.haskell.org}{haskell.org}.

Por outro lado, o mesmo ficheiro \texttt{cp2122t.lhs} é executável e contém
o ``kit'' básico, escrito em \Haskell, para realizar o trabalho. Basta executar
\begin{Verbatim}[fontsize=\small]
    $ ghci cp2122t.lhs
\end{Verbatim}

\noindent Abra o ficheiro \texttt{cp2122t.lhs} no seu editor de texto preferido
e verifique que assim é: todo o texto que se encontra dentro do ambiente
\begin{quote}\small\tt
\text{\ttfamily \char92{}begin\char123{}code\char125{}}
\\ ... \\
\text{\ttfamily \char92{}end\char123{}code\char125{}}
\end{quote}
é seleccionado pelo \GHCi\ para ser executado.

\subsection{Como realizar o trabalho}
Este trabalho teórico-prático deve ser realizado por grupos de 3 (ou 4) alunos.
Os detalhes da avaliação (datas para submissão do relatório e sua defesa
oral) são os que forem publicados na \cp{página da disciplina} na \emph{internet}.

Recomenda-se uma abordagem participativa dos membros do grupo em todos os
exercícios do trabalho, para assim poderem responder a qualquer questão colocada
na \emph{defesa oral} do relatório.

Em que consiste, então, o \emph{relatório} a que se refere o parágrafo anterior?
É a edição do texto que está a ser lido, preenchendo o anexo \ref{sec:resolucao}
com as respostas. O relatório deverá conter ainda a identificação dos membros
do grupo de trabalho, no local respectivo da folha de rosto.

Para gerar o PDF integral do relatório deve-se ainda correr os comando seguintes,
que actualizam a bibliografia (com \Bibtex) e o índice remissivo (com \Makeindex),
\begin{Verbatim}[fontsize=\small]
    $ bibtex cp2122t.aux
    $ makeindex cp2122t.idx
\end{Verbatim}
e recompilar o texto como acima se indicou.

No anexo \ref{sec:codigo} disponibiliza-se algum código \Haskell\ relativo
aos problemas que se seguem. Esse anexo deverá ser consultado e analisado
à medida que isso for necessário.

\subsection{Como exprimir cálculos e diagramas em LaTeX/lhs2tex}
Como primeiro exemplo, estudar o texto fonte deste trabalho para obter o
efeito:\footnote{Exemplos tirados de \cite{Ol18}.}
\begin{eqnarray*}
\start
     \ensuremath{\Varid{id}\mathrel{=}\conj{\Varid{f}}{\Varid{g}}}
%
\just\equiv{ universal property }
%
        \ensuremath{\begin{lcbr}\p1\comp \Varid{id}\mathrel{=}\Varid{f}\\\p2\comp \Varid{id}\mathrel{=}\Varid{g}\end{lcbr}}
%
\just\equiv{ identity }
%
        \ensuremath{\begin{lcbr}\p1\mathrel{=}\Varid{f}\\\p2\mathrel{=}\Varid{g}\end{lcbr}}
\qed
\end{eqnarray*}

Os diagramas podem ser produzidos recorrendo à \emph{package} \LaTeX\
\href{https://ctan.org/pkg/xymatrix}{xymatrix}, por exemplo:
\begin{eqnarray*}
\xymatrix@C=2cm{
    \ensuremath{\N_0}
           \ar[d]_-{\ensuremath{\cataNat{\Varid{g}}}}
&
    \ensuremath{\mathrm{1}\mathbin{+}\N_0}
           \ar[d]^{\ensuremath{\Varid{id}\mathbin{+}\cataNat{\Varid{g}}}}
           \ar[l]_-{\ensuremath{\mathsf{in}}}
\\
     \ensuremath{\Conid{B}}
&
     \ensuremath{\mathrm{1}\mathbin{+}\Conid{B}}
           \ar[l]^-{\ensuremath{\Varid{g}}}
}
\end{eqnarray*}

\section{Regra prática para a recursividade mútua em \ensuremath{\N_0}}\label{sec:mr}

Nesta disciplina estudou-se como fazer \pd{programação dinâmica} por cálculo,
recorrendo à lei de recursividade mútua.\footnote{Lei (\ref{eq:fokkinga})
em \cite{Ol18}, página \pageref{eq:fokkinga}.}

Para o caso de funções sobre os números naturais (\ensuremath{\N_0}, com functor
\ensuremath{\fun F \;\Conid{X}\mathrel{=}\mathrm{1}\mathbin{+}\Conid{X}}) é fácil derivar-se da lei que foi estudada uma
	\emph{regra de algibeira}
	\label{pg:regra}
que se pode ensinar a programadores que não tenham estudado
\cp{Cálculo de Programas}. Apresenta-se de seguida essa regra, tomando como
exemplo o cálculo do ciclo-\textsf{for} que implementa a função de Fibonacci,
recordar o sistema:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{fib}\;\mathrm{0}\mathrel{=}\mathrm{1}{}\<[E]%
\\
\>[B]{}\Varid{fib}\;(\Varid{n}\mathbin{+}\mathrm{1})\mathrel{=}\Varid{f}\;\Varid{n}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{f}\;\mathrm{0}\mathrel{=}\mathrm{1}{}\<[E]%
\\
\>[B]{}\Varid{f}\;(\Varid{n}\mathbin{+}\mathrm{1})\mathrel{=}\Varid{fib}\;\Varid{n}\mathbin{+}\Varid{f}\;\Varid{n}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Obter-se-á de imediato
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{fib'}\mathrel{=}\p1\comp \for{\Varid{loop}}\ {\Varid{init}}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{loop}\;(\Varid{fib},\Varid{f})\mathrel{=}(\Varid{f},\Varid{fib}\mathbin{+}\Varid{f}){}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{init}\mathrel{=}(\mathrm{1},\mathrm{1}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
usando as regras seguintes:
\begin{itemize}
\item	O corpo do ciclo \ensuremath{\Varid{loop}} terá tantos argumentos quanto o número de funções
mutuamente recursivas.
\item	Para as variáveis escolhem-se os próprios nomes das funções, pela ordem
que se achar conveniente.\footnote{Podem obviamente usar-se outros símbolos,
mas numa primeira leitura dá jeito usarem-se tais nomes.}
\item	Para os resultados vão-se buscar as expressões respectivas, retirando
a variável \ensuremath{\Varid{n}}.
\item	Em \ensuremath{\Varid{init}} coleccionam-se os resultados dos casos de base das funções,
pela mesma ordem.
\end{itemize}
Mais um exemplo, envolvendo polinómios do segundo grau $ax^2 + b x + c$ em \ensuremath{\N_0}.
Seguindo o método estudado nas aulas\footnote{Secção 3.17 de \cite{Ol18} e tópico
\href{https://www4.di.uminho.pt/~jno/media/cp/}{Recursividade mútua}
nos vídeos de apoio às aulas teóricas.},
de $f\ x = a x^2 + b x + c$ derivam-se duas funções mutuamente recursivas:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{f}\;\mathrm{0}\mathrel{=}\Varid{c}{}\<[E]%
\\
\>[B]{}\Varid{f}\;(\Varid{n}\mathbin{+}\mathrm{1})\mathrel{=}\Varid{f}\;\Varid{n}\mathbin{+}\Varid{k}\;\Varid{n}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{k}\;\mathrm{0}\mathrel{=}\Varid{a}\mathbin{+}\Varid{b}{}\<[E]%
\\
\>[B]{}\Varid{k}\;(\Varid{n}\mathbin{+}\mathrm{1})\mathrel{=}\Varid{k}\;\Varid{n}\mathbin{+}\mathrm{2}\;\Varid{a}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Seguindo a regra acima, calcula-se de imediato a seguinte implementação, em Haskell:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{f'}\;\Varid{a}\;\Varid{b}\;\Varid{c}\mathrel{=}\p1\comp \for{\Varid{loop}}\ {\Varid{init}}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{loop}\;(\Varid{f},\Varid{k})\mathrel{=}(\Varid{f}\mathbin{+}\Varid{k},\Varid{k}\mathbin{+}\mathrm{2}\mathbin{*}\Varid{a}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{init}\mathrel{=}(\Varid{c},\Varid{a}\mathbin{+}\Varid{b}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\section{O mónade das distribuições probabilísticas} \label{sec:probabilities}
Mónades são functores com propriedades adicionais que nos permitem obter
efeitos especiais em progra\-mação. Por exemplo, a biblioteca \Probability\
oferece um mónade para abordar problemas de probabilidades. Nesta biblioteca,
o conceito de distribuição estatística é captado pelo tipo
\begin{eqnarray}
	\ensuremath{\mathbf{newtype}\;\fun{Dist}\;\Varid{a}\mathrel{=}\Conid{D}\;\{\mskip1.5mu \Varid{unD}\mathbin{::}[\mskip1.5mu (\Varid{a},\Conid{ProbRep})\mskip1.5mu]\mskip1.5mu\}}
	\label{eq:Dist}
\end{eqnarray}
em que \ensuremath{\Conid{ProbRep}} é um real de \ensuremath{\mathrm{0}} a \ensuremath{\mathrm{1}}, equivalente a uma escala de $0$ a
$100 \%$.

Cada par \ensuremath{(\Varid{a},\Varid{p})} numa distribuição \ensuremath{\Varid{d}\mathbin{::}\fun{Dist}\;\Varid{a}} indica que a probabilidade
de \ensuremath{\Varid{a}} é \ensuremath{\Varid{p}}, devendo ser garantida a propriedade de  que todas as probabilidades
de \ensuremath{\Varid{d}} somam $100\%$.
Por exemplo, a seguinte distribuição de classificações por escalões de $A$ a $E$,
\[
\begin{array}{ll}
A & \rule{2mm}{3pt}\ 2\%\\
B & \rule{12mm}{3pt}\ 12\%\\
C & \rule{29mm}{3pt}\ 29\%\\
D & \rule{35mm}{3pt}\ 35\%\\
E & \rule{22mm}{3pt}\ 22\%\\
\end{array}
\]
será representada pela distribuição
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}d_1 \mathbin{::}\fun{Dist}\;\Conid{Char}{}\<[E]%
\\
\>[B]{}d_1 \mathrel{=}\Conid{D}\;[\mskip1.5mu (\text{\ttfamily 'A'},\mathrm{0.02}),(\text{\ttfamily 'B'},\mathrm{0.12}),(\text{\ttfamily 'C'},\mathrm{0.29}),(\text{\ttfamily 'D'},\mathrm{0.35}),(\text{\ttfamily 'E'},\mathrm{0.22})\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
que o \GHCi\ mostrará assim:
\begin{Verbatim}[fontsize=\small]
'D'  35.0%
'C'  29.0%
'E'  22.0%
'B'  12.0%
'A'   2.0%
\end{Verbatim}
É possível definir geradores de distribuições, por exemplo distribuições \emph{uniformes},
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}d_2 \mathrel{=}\Varid{uniform}\;(\Varid{words}\;\text{\ttfamily \char34 Uma~frase~de~cinco~palavras\char34}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
isto é
\begin{Verbatim}[fontsize=\small]
     "Uma"  20.0%
   "cinco"  20.0%
      "de"  20.0%
   "frase"  20.0%
"palavras"  20.0%
\end{Verbatim}
distribuição \emph{normais}, eg.\
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}d_3 \mathrel{=}\Varid{normal}\;[\mskip1.5mu \mathrm{10}\mathinner{\ldotp\ldotp}\mathrm{20}\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
etc.\footnote{Para mais detalhes ver o código fonte de \Probability, que é uma adaptação da
biblioteca \PFP\ (``Probabilistic Functional Programming''). Para quem quiser saber mais
recomenda-se a leitura do artigo \cite{EK06}.} \ensuremath{\fun{Dist}} forma um \textbf{mónade}
cuja unidade é \ensuremath{\Varid{return}\;\Varid{a}\mathrel{=}\Conid{D}\;[\mskip1.5mu (\Varid{a},\mathrm{1})\mskip1.5mu]} e cuja composição de Kleisli é (simplificando a notação)
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}(\Varid{f}\kcomp \Varid{g})\;\Varid{a}\mathrel{=}[\mskip1.5mu (\Varid{y},\Varid{q}\mathbin{*}\Varid{p})\mid (\Varid{x},\Varid{p})\leftarrow \Varid{g}\;\Varid{a},(\Varid{y},\Varid{q})\leftarrow \Varid{f}\;\Varid{x}\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
em que \ensuremath{\Varid{g}\mathbin{:}\Conid{A}\to \fun{Dist}\;\mathit B} e \ensuremath{\Varid{f}\mathbin{:}\mathit B\to \fun{Dist}\;\mathit C} são funções \textbf{monádicas} que representam
\emph{computações probabilísticas}.

Este mónade é adequado à resolução de problemas de \emph{probabilidades e
estatística} usando programação funcional, de forma elegante e como caso
particular da programação monádica.

\section{Código fornecido}\label{sec:codigo}

\subsection*{Problema 3}

Triângulo de base:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{base}\mathrel{=}((\mathrm{0},\mathrm{0}),\mathrm{32}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Desenho de triângulos em \svg:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{desenha}\;\Varid{x}\mathrel{=}\Varid{picd''}\;[\mskip1.5mu \Varid{scale}\;\mathrm{0.44}\;(\mathrm{0},\mathrm{0})\;(\Varid{x}\bind \Varid{tri2svg})\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Função que representa cada triângulo em \svg:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{tri2svg}\mathbin{::}\Conid{Tri}\to \Conid{Svg}{}\<[E]%
\\
\>[B]{}\Varid{tri2svg}\;(\Varid{p},\Varid{c})\mathrel{=}(\Varid{red}\comp \Varid{polyg})\;[\mskip1.5mu \Varid{p},\Varid{p}\mathbin{.+}(\mathrm{0},\Varid{c}),\Varid{p}\mathbin{.+}(\Varid{c},\mathrm{0})\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\textbf{NB}: o  tipo \ensuremath{\Conid{Svg}} é sinónimo de \ensuremath{\Conid{String}}:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{type}\;\Conid{Svg}\mathrel{=}\Conid{String}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\subsection*{Problema 4}
Funções básicas:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{type}\;\Conid{Bit}\mathrel{=}\Conid{Int}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathbf{type}\;\Conid{Bin}\mathrel{=}[\mskip1.5mu \Conid{Bit}\mskip1.5mu]{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathbf{type}\;\Conid{Bit3}\mathrel{=}(\Conid{Bit},\Conid{Bit},\Conid{Bit}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{tobin}\mathrel{=}\Varid{rtrim}\;\mathrm{5}\comp \Varid{pad}\;\mathrm{5}\comp \Varid{dec2bin}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{frombin}\mathrel{=}\Varid{bin2dec}\comp \Varid{rtrim}\;\mathrm{5}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{bin2dec}\mathbin{::}\Conid{Bin}\to \Conid{Int}{}\<[E]%
\\
\>[B]{}\Varid{bin2dec}\;[\mskip1.5mu \Varid{a}\mskip1.5mu]\mathrel{=}\Varid{a}{}\<[E]%
\\
\>[B]{}\Varid{bin2dec}\;\Varid{b}{}\<[13]%
\>[13]{}\mathrel{=}\Varid{bin2dec}\;(\Varid{init}\;\Varid{b})\mathbin{*}\mathrm{2}\mathbin{+}\Varid{last}\;\Varid{b}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{rtrim}\;\Varid{n}\;\Varid{a}\mathrel{=}\Varid{drop}\;(\length \;\Varid{a}\mathbin{-}\Varid{n})\;\Varid{a}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{dec2bin}\;\mathrm{0}\mathrel{=}[\mskip1.5mu \mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{dec2bin}\;\Varid{n}\mathrel{=}\Varid{dec2bin}\;\Varid{m}\mathbin{+\!\!\!+}[\mskip1.5mu \Varid{b}\mskip1.5mu]\;\mathbf{where}\;(\Varid{m},\Varid{b})\mathrel{=}(\Varid{n}\div \mathrm{2},\Varid{mod}\;\Varid{n}\;\mathrm{2}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{pad}\;\Varid{n}\;\Varid{x}\mathrel{=}\Varid{take}\;\Varid{m}\;\Varid{zeros}\mathbin{+\!\!\!+}\Varid{x}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{m}\mathrel{=}\Varid{n}\mathbin{-}\length \;\Varid{x}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{zeros}\mathrel{=}\mathrm{0}\mathbin{:}\Varid{zeros}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{bflips}\mathrel{=}\Varid{propagate}\;\Varid{bflip}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Função que vota no bit mais frequente:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}v_3 \;(\mathrm{0},\mathrm{0},\mathrm{0})\mathrel{=}\mathrm{0}{}\<[E]%
\\
\>[B]{}v_3 \;(\mathrm{0},\mathrm{0},\mathrm{1})\mathrel{=}\mathrm{0}{}\<[E]%
\\
\>[B]{}v_3 \;(\mathrm{0},\mathrm{1},\mathrm{0})\mathrel{=}\mathrm{0}{}\<[E]%
\\
\>[B]{}v_3 \;(\mathrm{0},\mathrm{1},\mathrm{1})\mathrel{=}\mathrm{1}{}\<[E]%
\\
\>[B]{}v_3 \;(\mathrm{1},\mathrm{0},\mathrm{0})\mathrel{=}\mathrm{0}{}\<[E]%
\\
\>[B]{}v_3 \;(\mathrm{1},\mathrm{0},\mathrm{1})\mathrel{=}\mathrm{1}{}\<[E]%
\\
\>[B]{}v_3 \;(\mathrm{1},\mathrm{1},\mathrm{0})\mathrel{=}\mathrm{1}{}\<[E]%
\\
\>[B]{}v_3 \;(\mathrm{1},\mathrm{1},\mathrm{1})\mathrel{=}\mathrm{1}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Descodificação monádica:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{dec'}\mathrel{=}\mathsf{fmap}\;\Varid{dec}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Para visualização abreviada de distribuições:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{consolidate}\mathbin{::}\Conid{Eq}\;\Varid{a}\Rightarrow \fun{Dist}\;\Varid{a}\to \fun{Dist}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\Varid{consolidate}\mathrel{=}\Conid{D}\comp \Varid{filter}\;\Varid{q}\comp \map \;(\Varid{id}\times\Varid{sum})\comp \Varid{collect}\comp \Varid{unD}\;\mathbf{where}\;\Varid{q}\;(\Varid{a},\Varid{p})\mathrel{=}\Varid{p}\mathbin{>}\mathrm{0.001}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{collect}\;\Varid{x}\mathrel{=}\Varid{nub}\;[\mskip1.5mu \Varid{k}\mapsto\Varid{nub}\;[\mskip1.5mu \Varid{d'}\mid (\Varid{k'},\Varid{d'})\leftarrow \Varid{x},\Varid{k'}\equiv \Varid{k}\mskip1.5mu]\mid (\Varid{k},\Varid{d})\leftarrow \Varid{x}\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

%----------------- Soluções dos alunos -----------------------------------------%

\section{Soluções dos alunos}\label{sec:resolucao}

Os alunos devem colocar neste anexo\footnote{E apenas neste anexo,
i.e, não podem alterar o resto do documento.} as suas soluções para os
exercícios propostos, de acordo com o "layout" que se fornece. Não podem
ser alterados os nomes ou tipos das funções dadas, mas podem ser adicionadas
outras funções auxiliares que sejam necessárias, bem como 
textos, inc.\ diagramas que expliquem como se chegou às soluções encontradas.

Valoriza-se a escrita de \emph{pouco} código que corresponda a soluções
simples e elegantes.

\subsection*{Problema 1} \label{pg:P1}

Por estudo e aplicação da regra prática no anexo \ref{sec:mr}, entendemos que, 
para chegarmos à definição apresentada, devemos ter em conta os condicionais em cada uma das funções.

Para determinar \ensuremath{\Varid{aux}\;\Varid{d}\mathrel{=}\conj{\Varid{q}\;\Varid{d}}{\conj{\Varid{r}\;\Varid{d}}{\Varid{c}\;\Varid{d}}}} é necessário determinar cada uma das funções
de tal forma que se possa utilizar a regra de \ensuremath{\Conid{Fokkinga}}. O functor aplicável neste caso é o functor de naturais,
isto é, \ensuremath{\Conid{F}\;\Varid{f}\mathrel{=}\Varid{id}\mathbin{+}\Varid{f}}. Nesse sentido, \ensuremath{\Conid{F}\;\conj{\Varid{q}\;\Varid{d}}{\conj{\Varid{r}\;\Varid{d}}{\Varid{c}\;\Varid{d}}}\mathrel{=}\Varid{id}\mathbin{+}\conj{\Varid{q}\;\Varid{d}}{\conj{\Varid{r}\;\Varid{d}}{\Varid{c}\;\Varid{d}}}}.

\begin{eqnarray*}
\start
        \ensuremath{\begin{lcbr}\Varid{q}\;\Varid{d}\;\mathrm{0}\mathrel{=}\mathrm{0}\\\Varid{q}\;\Varid{d}\;(\Varid{n}\mathbin{+}\mathrm{1})\mathrel{=}\Varid{q}\;\Varid{d}\;\Varid{n}\mathbin{+}(\Varid{x}\equiv \mathrm{0})\to \mathrm{1},\mathrm{0}\;\mathbf{where}\;\Varid{x}\mathrel{=}\Varid{c}\;\Varid{d}\;\Varid{n}\end{lcbr}}
%
\just\equiv{ (72), (74), (71); (72), (78), substituir \ensuremath{\Varid{x}}, def succ }
%
        \ensuremath{\begin{lcbr}(\Varid{q}\;\Varid{d})\comp \underline{\mathrm{0}}\mathrel{=}\underline{\mathrm{0}}\\((\Varid{q}\;\Varid{d})\comp \succ )\;\Varid{n}\mathrel{=}(\Varid{q}\;\Varid{d})\;\Varid{n}\mathbin{+}((\equiv \mathrm{0})\;(\Varid{c}\;\Varid{d}\;\Varid{n})\to \mathrm{1},\mathrm{0})\end{lcbr}}
%
\just\equiv{ (84), uncurry(+) = add, (76), (72), (71) }
%
     \ensuremath{\begin{lcbr}(\Varid{q}\;\Varid{d})\comp \underline{\mathrm{0}}\mathrel{=}\underline{\mathrm{0}}\\(\Varid{q}\;\Varid{d})\comp \succ \mathrel{=}\Varid{add}\comp \conj{\Varid{q}\;\Varid{d}}{(\equiv \mathrm{0})\comp (\Varid{cd})\to \underline{\mathrm{1}},\underline{\mathrm{0}}}\end{lcbr}}
%
\just\equiv{ (27), def inNat }
%
     \ensuremath{(\Varid{q}\;\Varid{d})\comp \mathsf{in}\mathrel{=}\alt{\underline{\mathrm{0}}}{\Varid{add}\comp \conj{\Varid{q}\;\Varid{d}}{(\equiv \mathrm{0})\comp (\Varid{cd})\to \underline{\mathrm{1}},\underline{\mathrm{0}}}}}
%
\just\equiv{ (3), (32), (7), (1)}
%
     \ensuremath{(\Varid{q}\;\Varid{d})\comp \mathsf{in}\mathrel{=}\alt{\underline{\mathrm{0}}}{\Varid{add}\comp \conj{\Varid{id}\comp (\Varid{qd})}{((\equiv \mathrm{0})\to \underline{\mathrm{1}},\underline{\mathrm{0}})\comp \p2\comp \conj{\Varid{r}\;\Varid{d}}{\Varid{c}\;\Varid{d}}}}}
%
\just\equiv{ (11), (22) }
%
     \ensuremath{(\Varid{q}\;\Varid{d})\comp \mathsf{in}\mathrel{=}\alt{\underline{\mathrm{0}}}{\Varid{add}\comp (\Varid{id}\times(((\equiv \mathrm{0})\to \underline{\mathrm{1}},\underline{\mathrm{0}})\comp \p2))}\comp (\Varid{id}\mathbin{+}\conj{\Varid{q}\;\Varid{d}}{\conj{\Varid{r}\;\Varid{d}}{\Varid{c}\;\Varid{d}}})}
\qed
\end{eqnarray*}

Analogamente, consegue-se chegar às definições de \ensuremath{\Varid{r}\;\Varid{d}} e de \ensuremath{\Varid{c}\;\Varid{d}}:

\begin{eqnarray*}
\start
     \ensuremath{\begin{lcbr}(\Varid{r}\;\Varid{d})\comp \mathsf{in}\mathrel{=}\alt{\underline{\mathrm{0}}}{((\equiv \mathrm{0})\comp \p2\to \underline{\mathrm{0}},\succ \comp \p1)\comp \p2}\comp (\Varid{id}\mathbin{+}\conj{\Varid{q}\;\Varid{d}}{\conj{\Varid{r}\;\Varid{d}}{\Varid{c}\;\Varid{d}}})\\(\Varid{c}\;\Varid{d})\comp \mathsf{in}\mathrel{=}\alt{\underline{\Varid{d}}}{((\equiv \mathrm{0})\to \underline{\Varid{d}},(\mathbin{-}\mathrm{1}))\comp \p2\comp \p2}\comp (\Varid{id}\mathbin{+}\conj{\Varid{q}\;\Varid{d}}{\conj{\Varid{r}\;\Varid{d}}{\Varid{c}\;\Varid{d}}})\end{lcbr}}
\qed
\end{eqnarray*}

Aplicando a regra de \ensuremath{\Conid{Fokkinga}}, para \ensuremath{\Varid{aux}\;\Varid{d}\mathrel{=}\conj{\Varid{q}\;\Varid{d}}{\conj{\Varid{r}\;\Varid{d}}{\Varid{c}\;\Varid{d}}}} e com:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{q'}\;\Varid{d}\mathrel{=}(\Varid{add}\comp (\Varid{id}\times((\Varid{\Conid{Cp}.cond}\;(\equiv \mathrm{0})\;\underline{\mathrm{1}}\;\underline{\mathrm{0}})\comp \p2))){}\<[E]%
\\
\>[B]{}\Varid{r'}\;\Varid{d}\mathrel{=}((\Varid{\Conid{Cp}.cond}\;((\equiv \mathrm{0})\comp \p2)\;\underline{\mathrm{0}}\;(\succ \comp \p1))\comp \p2){}\<[E]%
\\
\>[B]{}\Varid{c'}\;\Varid{d}\mathrel{=}((\Varid{\Conid{Cp}.cond}\;(\equiv \mathrm{0})\;\underline{\Varid{d}}\;(\mathbin{-}\mathrm{1}))\comp \p2\comp \p2){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\begin{eqnarray*}
\start
     \ensuremath{\Varid{aux}\;\Varid{d}\mathrel{=}\cataNat{\conj{\alt{\underline{\mathrm{0}}}{\Varid{q'}\;\Varid{d}}}{\alt{\underline{\mathrm{0}}}{\Varid{r'}\;\Varid{d}}}\;\alt{\underline{\Varid{d}}}{\Varid{c'}\;\Varid{d}}}}
%
\just\equiv{ (28) duas vezes }
%
     \ensuremath{\Varid{aux}\;\Varid{d}\mathrel{=}\cataNat{\alt{\conj{\underline{\mathrm{0}}}{\conj{\underline{\mathrm{0}}}{\underline{\Varid{d}}}}}{\conj{\Varid{q'}\;\Varid{d}}{\conj{\Varid{r'}\;\Varid{d}}{\Varid{c'}\;\Varid{d}}}}}}
\qed
\end{eqnarray*}

Seja \ensuremath{\Varid{g}\;\Varid{d}\mathrel{=}\conj{\Varid{q'}\;\Varid{d}}{\conj{\Varid{r'}\;\Varid{d}}{\Varid{c'}\;\Varid{d}}}}. Pelo tipo de \ensuremath{\Varid{aux}\;\Varid{d}\mathrel{=}\conj{\Varid{q}\;\Varid{d}}{\conj{\Varid{r}\;\Varid{d}}{\Varid{c}\;\Varid{d}}}}:

\begin{eqnarray*}
\xymatrix@C=2cm{
    \ensuremath{\N_0}
          \ar[d]_-{\ensuremath{\Varid{aux}\;\Varid{d}}}
&
    \ensuremath{\mathrm{1}\mathbin{+}\N_0\times(\N_0\times\N_0)}
          \ar[d]^{\ensuremath{\Varid{id}\mathbin{+}\conj{\Varid{q}\;\Varid{d}}{\conj{\Varid{r}\;\Varid{d}}{\Varid{c}\;\Varid{d}}}}}
          \ar[l]_-{\ensuremath{\mathsf{in}}}
\\
    \ensuremath{\N_0}
&
     \ensuremath{\mathrm{1}\mathbin{+}\N_0\times(\N_0\times\N_0)}
          \ar[l]^{\ensuremath{\alt{\conj{\underline{\mathrm{0}}}{\conj{\underline{\mathrm{0}}}{\underline{\Varid{d}}}}}{\Varid{g}\;\Varid{d}}}}
}
\end{eqnarray*}

Deduzimos o tipo de \ensuremath{\Varid{g}\;\Varid{d}\mathbin{::}\N_0\times(\N_0\times\N_0)\to \N_0\times(\N_0\times\N_0)}. Assim, podemos definir \ensuremath{\Varid{g}\;\Varid{d}} de forma \ensuremath{\Varid{point}\mathbin{-}\Varid{wise}},
com pares \ensuremath{(\Varid{q},(\Varid{r},\Varid{c}))} pertencentes a \ensuremath{\N_0\times(\N_0\times\N_0)}. Vemos pelas definições de cada função que faz parte de \ensuremath{\Varid{g}\;\Varid{d}} que
todas elas têm comportamentos distintos para o caso de \ensuremath{\Varid{c}} ser igual a \ensuremath{\mathrm{0}} ou de ser diferente. Desse modo, podemos definir \ensuremath{\Varid{g}\;\Varid{d}}
por esses dois casos, ou seja, se \ensuremath{\Varid{g}\;\Varid{d}} receber \ensuremath{(\Varid{q},(\Varid{r},\mathrm{0}))} ou se receber \ensuremath{(\Varid{q},(\Varid{r},\Varid{c}\mathbin{+}\mathrm{1}))}, o que determina completamente o domínio da função,
já que \ensuremath{\Varid{c}} pertence a \ensuremath{\N_0}. 
Assim, tendo em conta que \ensuremath{\Varid{g}\;\Varid{d}\;(\Varid{q},(\Varid{r},\Varid{c}))\mathrel{=}(\Varid{q'}\;\Varid{d}\;(\Varid{q},(\Varid{r},\Varid{c})),(\Varid{r'}\;\Varid{d}\;(\Varid{q},(\Varid{r},\Varid{c})),\Varid{c'}\;\Varid{d}\;(\Varid{q},(\Varid{r},\Varid{c}))))} pela regra (76):
\begin{eqnarray*}
\start
     \ensuremath{\begin{lcbr}\Varid{g}\;\Varid{d}\;(\Varid{q},(\Varid{r},\mathrm{0}))\mathrel{=}(\Varid{q}\mathbin{+}\mathrm{1},(\mathrm{0},\Varid{d}))\\\Varid{g}\;\Varid{d}\;(\Varid{q},(\Varid{r},\Varid{c}\mathbin{+}\mathrm{1}))\mathrel{=}(\Varid{q},(\Varid{r}\mathbin{+}\mathrm{1},\Varid{c}))\end{lcbr}}
\qed
\end{eqnarray*}

Concluindo:

\begin{eqnarray*}
\start
     \ensuremath{\Varid{aux}\;\Varid{d}\mathrel{=}\cataNat{\alt{\conj{\underline{\mathrm{0}}}{\conj{\underline{\mathrm{0}}}{\underline{\Varid{d}}}}}{\conj{\Varid{q'}\;\Varid{d}}{\conj{\Varid{r'}\;\Varid{d}}{\Varid{c'}\;\Varid{d}}}}}}
%
\just\equiv{def (\ensuremath{\Varid{g}\;\Varid{d}}), ficha 3}
%
     \ensuremath{\Varid{aux}\;\Varid{d}\mathrel{=}\cataNat{\alt{\underline{(\mathrm{0},(\mathrm{0},\Varid{d}))}}{\Varid{g}\;\Varid{d}}}}
%
\just\equiv{def for}
%
     \ensuremath{\Varid{aux}\;\Varid{d}\mathrel{=}\for{\Varid{g}\;\Varid{d}}\ {\mathrm{0},(\mathrm{0},\Varid{d})}}
%
\just\equiv{def (\ensuremath{\Varid{loop}\;\Varid{d}})}
%
     \ensuremath{\Varid{aux}\;\Varid{d}\mathrel{=}\Varid{loop}\;\Varid{d}}
\qed
\end{eqnarray*}

\subsection*{Problema 2}

Na resolução deste problema resolvemos definir inicialmente as funções \ensuremath{\Varid{alice}}, a que chamamos \ensuremath{\Varid{a}} e \ensuremath{\Varid{bob}}, a que chamamos \ensuremath{\Varid{b}}.
Definimos \ensuremath{\Varid{alice}} e \ensuremath{\Varid{bob}} inicialmente em modo pointwise tal que:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{alice}\mathbin{::}\Conid{Ord}\;\Varid{c}\Rightarrow {\LTree}\;\Varid{c}\to \Varid{c}{}\<[E]%
\\
\>[B]{}\Varid{alice}\;(\Conid{Leaf}\;\Varid{x})\mathrel{=}\Varid{id}\;\Varid{x}{}\<[E]%
\\
\>[B]{}\Varid{alice}\;(\Conid{Fork}\;(\Varid{t1},\Varid{t2}))\mathrel{=}(\uncurry{\Varid{max}}\comp (\Varid{bob}\times\Varid{bob}))\;(\Varid{t1},\Varid{t2}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{bob}\mathbin{::}\Conid{Ord}\;\Varid{c}\Rightarrow {\LTree}\;\Varid{c}\to \Varid{c}{}\<[E]%
\\
\>[B]{}\Varid{bob}\;(\Conid{Leaf}\;\Varid{x})\mathrel{=}\Varid{id}\;\Varid{x}{}\<[E]%
\\
\>[B]{}\Varid{bob}\;(\Conid{Fork}\;(\Varid{t1},\Varid{t2}))\mathrel{=}(\uncurry{\Varid{min}}\comp (\Varid{alice}\times\Varid{alice}))\;(\Varid{t1},\Varid{t2}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Procuramos agora manipular estas definições para que seja possivel aplicar a lei \ensuremath{\Conid{Fokkinga}}.
\begin{eqnarray*}
\start
     \ensuremath{\begin{lcbr}\Varid{a}\comp \Varid{leaf}\;\Varid{x}\mathrel{=}\Varid{id}\;\Varid{x}\\\Varid{a}\comp \Conid{Fork}\;(\Varid{t1},\Varid{t2})\mathrel{=}\uncurry{\Varid{max}}\;(\Varid{b}\times\Varid{b})\;(\Varid{t1},\Varid{t2})\end{lcbr}}
%
\just\equiv{(71)}
%
     \ensuremath{\begin{lcbr}\Varid{a}\comp \Varid{leaf}\mathrel{=}\Varid{id}\\\Varid{a}\comp \Conid{Fork}\mathrel{=}\uncurry{\Varid{max}}\;(\Varid{b}\times\Varid{b})\end{lcbr}}
%
\just\equiv{(27)}
%
     \ensuremath{\alt{\Varid{a}\comp \Conid{Leaf}}{\Varid{a}\comp \Conid{Fork}}\mathrel{=}\alt{\Varid{id}}{\uncurry{\Varid{max}}}\comp (\Varid{b}\times\Varid{b})}
%
\just\equiv{(20)}
%
     \ensuremath{\Varid{a}\comp \alt{\Conid{Leaf}}{\Conid{Fork}}\mathrel{=}\alt{\Varid{id}}{\uncurry{\Varid{max}}}\comp (\Varid{b}\times\Varid{b})}
%
\just\equiv{(def in)}
%
     \ensuremath{\Varid{a}\comp \mathbf{in}\mathrel{=}\alt{\Varid{id}}{\uncurry{\Varid{max}}}\comp (\Varid{b}\times\Varid{b})}
%
\just\equiv{(1),(7)}
%
     \ensuremath{\Varid{a}\comp \mathbf{in}\mathrel{=}\alt{\Varid{id}}{\cdot }\comp \Varid{id}\;\uncurry{\Varid{max}}\comp (\p2\comp \conj{\Varid{a}}{\Varid{b}}\times\p2\comp \conj{\Varid{a}}{\Varid{b}})}
%
\just\equiv{(14)}
%
     \ensuremath{\Varid{a}\comp \mathbf{in}\mathrel{=}\alt{\Varid{id}}{\cdot }\comp \Varid{id}\;\uncurry{\Varid{max}}\comp (\p2\times\p2)\comp (\conj{\Varid{a}}{\Varid{b}}\times\conj{\Varid{a}}{\Varid{b}})}
%
\just\equiv{(22)}
%
     \ensuremath{\Varid{a}\comp \mathbf{in}\mathrel{=}(\alt{\Varid{id}}{\uncurry{\Varid{max}}}\comp (\p2\times\p2))\comp (\Varid{id}\mathbin{+}(\conj{\Varid{a}}{\Varid{b}}\times\conj{\Varid{a}}{\Varid{b}}))}
%
\just\equiv{(def F(split a b))}
%
     \ensuremath{\Varid{a}\comp \mathbf{in}\mathrel{=}\alt{\Varid{id}}{\uncurry{\Varid{max}}\;(\p2\times\p2)}\comp \Conid{F}\;\conj{\Varid{a}}{\Varid{b}}}
\qed
\end{eqnarray*}

O calculo para b é feito de modo inteiramente análogo.
Ficamos então com:
\begin{eqnarray*}
\start
     \ensuremath{\begin{lcbr}\Varid{a}\comp \mathbf{in}\mathrel{=}\alt{\Varid{id}}{\uncurry{\Varid{max}}\;(\p2\times\p2)}\comp \Conid{F}\;\conj{\Varid{a}}{\Varid{b}}\\\Varid{b}\comp \mathbf{in}\mathrel{=}\alt{\Varid{id}}{\uncurry{\Varid{min}}\;(\p1\times\p1)}\comp \Conid{F}\;\conj{\Varid{a}}{\Varid{b}}\end{lcbr}}
%
\just\equiv{(52)}
%
     \ensuremath{\conj{\Varid{a}}{\Varid{b}}\mathrel{=}\llparenthesis\, \conj{\alt{\Varid{id}}{\uncurry{\Varid{max}}\comp (\p2\times\p2)}}{\alt{\Varid{id}}{\uncurry{\Varid{min}}\comp (\p1\times\p1)}}\,\rrparenthesis}
%
\just\equiv{both = split a b}
%
     \ensuremath{\conj{\Varid{a}}{\Varid{b}}\mathrel{=}\llparenthesis\, \conj{\alt{\Varid{id}}{\uncurry{\Varid{max}}\comp (\p2\times\p2)}}{\alt{\Varid{id}}{\uncurry{\Varid{min}}\comp (\p1\times\p1)}}\,\rrparenthesis}
\qed
\end{eqnarray*}

\codificado em Haskell: 
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{both}\mathbin{::}\Conid{Ord}\;\Varid{d}\Rightarrow {\LTree}\;\Varid{d}\to (\Varid{d},\Varid{d}){}\<[E]%
\\
\>[B]{}\Varid{both}\mathrel{=}\llparenthesis\, \conj{\alt{\Varid{id}}{\uncurry{\Varid{max}}\comp (\p2\times\p2)}}{\alt{\Varid{id}}{\uncurry{\Varid{min}}\comp (\p1\times\p1)}}\,\rrparenthesis{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\subsection*{Problema 3}

Biblioteca \ensuremath{\mathsf{LTree3}}:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{27}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{inLTree3}\mathbin{::}\Varid{a}+((\mathsf{LTree3}\;\Varid{a},\mathsf{LTree3}\;\Varid{a}),\mathsf{LTree3}\;\Varid{a})\to \mathsf{LTree3}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\Varid{inLTree3}\mathrel{=}\alt{\Conid{Tri}}{\uncurry{\uncurry{\Conid{Nodo}}}}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{outLTree3}\mathbin{::}\mathsf{LTree3}\;\Varid{a}\to \Varid{a}+((\mathsf{LTree3}\;\Varid{a},\mathsf{LTree3}\;\Varid{a}),\mathsf{LTree3}\;\Varid{a}){}\<[E]%
\\
\>[B]{}\Varid{outLTree3}\;(\Conid{Tri}\;\Varid{t})\mathrel{=}i_1\;\Varid{t}{}\<[E]%
\\
\>[B]{}\Varid{outLTree3}\;(\Conid{Nodo}\;\Varid{a}\;\Varid{b}\;\Varid{c})\mathrel{=}{}\<[27]%
\>[27]{}i_2\;((\Varid{a},\Varid{b}),\Varid{c}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{baseLTree3}\;\Varid{f}\;\Varid{g}\mathrel{=}\Varid{f}+((\Varid{g}\times\Varid{g})\times\Varid{g}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{recLTree3}\;\Varid{f}\mathrel{=}\Varid{baseLTree3}\;\Varid{id}\;\Varid{f}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{cataLTree3}\;\Varid{f}\mathrel{=}\Varid{f}\comp (\Varid{recLTree3}\;(\Varid{cataLTree3}\;\Varid{f}))\comp \Varid{outLTree3}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{anaLTree3}\;\Varid{f}\mathrel{=}\Varid{inLTree3}\comp (\Varid{recLTree3}\;(\Varid{anaLTree3}\;\Varid{f}))\comp \Varid{f}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{hyloLTree3}\;\Varid{f}\;\Varid{g}\mathrel{=}\Varid{cataLTree3}\;\Varid{f}\comp \Varid{anaLTree3}\;\Varid{g}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Genes do hilomorfismo \ensuremath{\Varid{sierpinski}}:
O g1 é o gene do catamorfismo e o g2 é o gene do anamorfismo.
Resolução do g1:
A partir de um Tri ou ((Tri*, Tri*), Tri*), queremos obter uma lista de Tri (Tri*).
Se for um tri, queremos colocar em uma lista singular, senão temos fazer a concatenação das três listas de Tri.
Optamos por escreve a função em haskell pointwise e passar para pointfree.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}g_1 \mathrel{=}\alt{\Varid{singl}}{\uncurry{(\mathbin{+\!\!\!+})}\comp ((\uncurry{(\mathbin{+\!\!\!+})}\times\Varid{id}))}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}g_2 \;(\Varid{t},\mathrm{0})\mathrel{=}i_1\;\Varid{t}{}\<[E]%
\\
\>[B]{}g_2 \;(((\Varid{x},\Varid{y}),\Varid{s}),\Varid{n})\mathrel{=}i_2\;((\Varid{t1},\Varid{t2}),\Varid{t3})\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{t1}\mathrel{=}(((\Varid{x},\Varid{y}),\Varid{s}\mathbin{\Varid{`div`}}\mathrm{2}),\Varid{n}\mathbin{-}\mathrm{1}){}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{t2}\mathrel{=}(((\Varid{x}\mathbin{+}\Varid{s}\mathbin{\Varid{`div`}}\mathrm{2},\Varid{y}),\Varid{s}\mathbin{\Varid{`div`}}\mathrm{2}),\Varid{n}\mathbin{-}\mathrm{1}){}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{t3}\mathrel{=}(((\Varid{x},\Varid{y}\mathbin{+}\Varid{s}\mathbin{\Varid{`div`}}\mathrm{2}),\Varid{s}\mathbin{\Varid{`div`}}\mathrm{2}),\Varid{n}\mathbin{-}\mathrm{1}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Diagramas do catamorfismo e anamorfismo:
\begin{eqnarray*}
\xymatrix@C=2cm{
    \ensuremath{\mathsf{LTree3}\;\Conid{Tri}}
           \ar[d]_-{\ensuremath{\Varid{cataLTree3}\;g_1 }}
&
    \ensuremath{\Conid{Tri}\mathbin{+}((\Conid{Int}\;\Varid{x}\;\Conid{Int})\;\Varid{x}\;\Conid{Int})}
           \ar[d]^{\ensuremath{\Varid{id}\mathbin{+}((g_1 \;\Varid{x}\;g_1 )\;\Varid{x}\;g_1 )}}
           \ar[l]_-{\ensuremath{\Varid{inLTree3}}}
\\
     \ensuremath{\Conid{Tri}\mathbin{*}}
&
     \ensuremath{\Conid{Tri}\mathbin{+}((\Conid{Tri}\mathbin{*}\Varid{x}\;\Conid{Tri}\mathbin{*}),\Conid{Tri}\mathbin{*})}
           \ar[l]^-{\ensuremath{g_1 }}
}

\xymatrix@C=2cm{
    \ensuremath{\Conid{Tri}\;\Varid{x}\;\Conid{Int}}
           \ar[r]_-{\ensuremath{g_2 }}
           \ar[d]_-{\ensuremath{\Varid{anaLTree3}\;g_2 }}
&
    \ensuremath{\Conid{Tri}\mathbin{+}((\Conid{Int}\;\Varid{x}\;\Conid{Int})\;\Varid{x}\;\Conid{Int})}
           \ar[d]^{\ensuremath{\Varid{id}\mathbin{+}((g_2 \;\Varid{x}\;g_2 )\;\Varid{x}\;g_2 )}}
\\
     \ensuremath{\mathsf{LTree3}\;\Conid{Tri}}
&
     \ensuremath{\Conid{Tri}\mathbin{+}((\Conid{Tri}\mathbin{*}\Varid{x}\;\Conid{Tri}\mathbin{*}),\Conid{Tri}\mathbin{*})}
           \ar[l]^-{\ensuremath{\Varid{inLTree3}}}
}

\end{eqnarray*}


\subsection*{Problema 4}

A função \ensuremath{\Varid{propagate}} tem como objetivo aplicar \ensuremath{\Varid{f}\mathbin{::}\Conid{Monad}\;\Varid{m}\Rightarrow (\Varid{t}\to \Varid{m}\;\Varid{a})} a todos os elementos da lista de entrada, analogamente a um \ensuremath{\map }.
Ao contrário dessa função, esta deve coletar todos os resultados em estrutura monádica dessa aplicação numa só estrutura
aplicada a uma lista, \ensuremath{\fun{Dist}\;[\mskip1.5mu \Conid{Bit}\mskip1.5mu]}, ao invés de uma lista de estruturas do mesmo tipo de saída de \ensuremath{\Varid{f}}, [Dist Bit].
Então, para se definir a função \ensuremath{\Varid{propagate}} é necessário definir o seu comportamento, depois de receber a função \ensuremath{\Varid{f}}.
Renomeie-se os tipos das funções tais que \ensuremath{\Varid{t}\equiv \Conid{A}} e \ensuremath{\Varid{a}\equiv \mathit B}.
Assim, para definir corretamente a função \ensuremath{\Varid{propagate}\;\Varid{f}} é necessário conhecer qual o gene do seu catamorfismo, 
uma função que obtenha \ensuremath{\Conid{M}\;[\mskip1.5mu \mathit B\mskip1.5mu]} a partir de \ensuremath{\mathrm{1}\mathbin{+}\Conid{A}\times\Conid{M}\;[\mskip1.5mu \mathit B\mskip1.5mu]}. 

Por um lado, a função \ensuremath{\Varid{f}} obtém \ensuremath{\Conid{M}\;\mathit B} a partir do elemento da cabeça da lista \ensuremath{\Conid{A}}, chegando então a \ensuremath{\mathrm{1}\mathbin{+}\Conid{M}\;\mathit B\times\Conid{M}\;[\mskip1.5mu \mathit B\mskip1.5mu]}.
Por outro lado, pretendemos concatenar o resultado \ensuremath{\mathit B}, retirando-lhe o mónade momentaneamente, 
ao resultado de aplicar a chamada recursiva à cauda, nomeadamente a função \ensuremath{\Varid{monad\char95 cons}} que retira do mónade os elementos do par
e devolve a concatenação no mónade, utilizando \ensuremath{\Varid{return}}.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{monad\char95 cons}\mathbin{::}\Conid{Monad}\;\Varid{m}\Rightarrow (\Varid{m}\;\Varid{a},\Varid{m}\;[\mskip1.5mu \Varid{a}\mskip1.5mu])\to \Varid{m}\;[\mskip1.5mu \Varid{a}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{monad\char95 cons}\;(\Varid{a},\Varid{b})\mathrel{=}\mathbf{do}\;\{\mskip1.5mu \Varid{x}\leftarrow \Varid{a};\Varid{y}\leftarrow \Varid{b};\Varid{return}\;(\Varid{x}\mathbin{:}\Varid{y})\mskip1.5mu\}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Ambas estes passos podem ser compostos na função \ensuremath{g_2 }, definida na solução, 
que aplica \ensuremath{\Varid{f}} ao elemento à cabeça antes de o concatenar, por absorção.

\begin{eqnarray*}
\start
     \ensuremath{g_2 \mathrel{=}\alt{\Varid{return}\comp \Varid{nil}}{\Varid{monad\char95 cons}}\comp (\Varid{id}\mathbin{+}\Varid{f}\times\Varid{id})}
%
\just\equiv{(22); (1)}
%
     \ensuremath{g_2 \mathrel{=}\alt{\Varid{return}\comp \Varid{nil}}{\Varid{monad\char95 cons}\comp (\Varid{f}\times\Varid{id})}}
\qed
\end{eqnarray*}

\begin{eqnarray*}
\start
     \ensuremath{(\Varid{monad\char95 cons}\comp (\Varid{f}\times\Varid{id}))\;(\Varid{a},\Varid{b})}
%
\just ={(72); (77); (1)}
%
     \ensuremath{\Varid{monad\char95 cons}\;(\Varid{f}\;\Varid{a},\Varid{b})}
\qed
\end{eqnarray*}

No caso do elemento pertencer ao tipo \ensuremath{\mathrm{1}}, o que corresponde à lista vazia, o gene deve criar uma estrutura monádica com a lista vazia, 
isto é, aplicar \ensuremath{\Varid{return}} após \ensuremath{\Varid{nil}} ao elemento \ensuremath{()}.

\begin{eqnarray*}
\xymatrix@C=2cm{
    \ensuremath{[\mskip1.5mu \Conid{A}\mskip1.5mu]}
          \ar[d]_-{\ensuremath{\Varid{propagate}\;\Varid{f}}}
&
    \ensuremath{\mathrm{1}\mathbin{+}\Conid{A}\times[\mskip1.5mu \Conid{A}\mskip1.5mu]}
          \ar[d]^{\ensuremath{\Varid{id}\mathbin{+}\Varid{id}\times(\Varid{propagate}\;\Varid{f})}}
          \ar[l]_-{\ensuremath{\Varid{inList}}}
\\
    \ensuremath{\Conid{M}\;[\mskip1.5mu \mathit B\mskip1.5mu]}
&
     \ensuremath{\mathrm{1}\mathbin{+}\Conid{A}\times\Conid{M}\;[\mskip1.5mu \mathit B\mskip1.5mu]}
          \ar[l]^{\ensuremath{\alt{\Varid{return}\comp \Varid{nil}}{g_2 \;\Varid{f}}}}
          \ar[d]^{\ensuremath{\Varid{id}\mathbin{+}\Varid{f}\times\Varid{id}}}
\\
&
    \ensuremath{\mathrm{1}\mathbin{+}\Conid{M}\;\mathit B\times\Conid{M}\;[\mskip1.5mu \mathit B\mskip1.5mu]}
          \ar[ul]^{\ensuremath{\alt{\Varid{return}\comp \Varid{nil}}{g_1 }}}
}
\end{eqnarray*}

Definição de \ensuremath{\Varid{propagate}}:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{propagate}\mathbin{::}\Conid{Monad}\;\Varid{m}\Rightarrow (\Varid{t}\to \Varid{m}\;\Varid{a})\to [\mskip1.5mu \Varid{t}\mskip1.5mu]\to \Varid{m}\;[\mskip1.5mu \Varid{a}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{propagate}\;\Varid{f}\mathrel{=}\cataList{\Varid{g}\;\Varid{f}}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{g}\;\Varid{f}\mathrel{=}\alt{\Varid{return}\comp \Varid{nil}}{g_2 \;\Varid{f}}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}g_2 \;\Varid{f}\;(\Varid{a},\Varid{b})\mathrel{=}\mathbf{do}\;\{\mskip1.5mu \Varid{x}\leftarrow (\Varid{f}\;\Varid{a});\Varid{y}\leftarrow \Varid{b};\Varid{return}\;(\Varid{x}\mathbin{:}\Varid{y})\mskip1.5mu\}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Ao contrário de da função \ensuremath{\Varid{propagate}}, para se definir \ensuremath{\Varid{propagate3}}, é necessário explicitar os tipos de \ensuremath{\Varid{f}\mathbin{::}(\Conid{Monad}\;\Varid{m})\Rightarrow (\Conid{Bit3}\to \Varid{m}\;\Conid{Bit3})}, 
já que se pretende que \ensuremath{\Varid{propagate3}} triplique, especificamente, cada \ensuremath{\Conid{Bit}} da lista de entrada para uma estrutura do tipo \ensuremath{\Conid{Bit3}}, durante a sua execução.
A sequência de aplicações do gene, que manipulam a cabeça da lista, é a seguinte:

\begin{enumerate}
\item Construir o triplo \ensuremath{\Conid{Bit3}} a partir de \ensuremath{\Conid{Bit}}, replicando-o três vezes.
\item Aplicar \ensuremath{\Varid{f}} (por exemplo, \ensuremath{\Varid{bflip3}}) a \ensuremath{\Conid{Bit3}}, produzindo \ensuremath{\Varid{m}\;\Conid{Bit3}}.
\item Reduzir \ensuremath{\Varid{m}\;\Conid{Bit3}} a \ensuremath{\Varid{m}\;\Conid{Bit}}, utilizando a função \ensuremath{v_3 \mathbin{::}\Conid{Bit3}\to \Conid{Bit}} estendida para se 
aplicar a \ensuremath{\Varid{m}\;\Conid{Bit3}} com o \ensuremath{\Varid{functor}} desse mónade, através de \ensuremath{\mathsf{fmap}}.
\item Reconstruir \ensuremath{\Varid{m}\;[\mskip1.5mu \Conid{Bit}\mskip1.5mu]} de forma análoga a \ensuremath{\Varid{propagate}}, através de
\ensuremath{\alt{\Varid{return}\comp \Varid{nil}}{g_1 \;\Varid{f}}}.
\end{enumerate}

Tal como anteriormente, todos estes passos podem ser compostos com \ensuremath{g_1 } numa só função por sucessivas aplicações da regra de \ensuremath{\Varid{absorção}\mathbin{-+}}.

\begin{eqnarray*}
\xymatrix@C=2cm{
    \ensuremath{[\mskip1.5mu \Conid{Bit}\mskip1.5mu]}
           \ar[d]_-{\ensuremath{\Varid{propagate3}\;\Varid{f}}}
&
    \ensuremath{\mathrm{1}\mathbin{+}\Conid{Bit}\times\Conid{M}\;[\mskip1.5mu \Conid{Bit}\mskip1.5mu]}
           \ar[d]^{\ensuremath{\Varid{id}\mathbin{+}\Varid{id}\times(\Varid{propagate3}\;\Varid{f})}}
           \ar[l]_-{\ensuremath{\Varid{inList}}}
\\
     \ensuremath{\Conid{M}\;[\mskip1.5mu \Conid{Bit}\mskip1.5mu]}
&
     \ensuremath{\mathrm{1}\mathbin{+}\Conid{Bit}\times\Conid{M}\;[\mskip1.5mu \Conid{Bit}\mskip1.5mu]}
            \ar[l]^{\ensuremath{\alt{\Varid{return}\comp \Varid{nil}}{g_2 \;\Varid{f}}}}
           \ar[d]^{\ensuremath{\Varid{id}\mathbin{+}(\Varid{a},\Varid{a},\Varid{a})\times\Varid{id}}}
\\
&
    \ensuremath{\mathrm{1}\mathbin{+}\Conid{Bit3}\times\Conid{M}\;[\mskip1.5mu \Conid{Bit}\mskip1.5mu]}
        \ar[d]^{\ensuremath{\Varid{id}\mathbin{+}\Varid{bitflip3}\times\Varid{id}}}
\\
&
    \ensuremath{\mathrm{1}\mathbin{+}\Conid{M}\;\Conid{Bit3}\times\Conid{M}\;[\mskip1.5mu \Conid{Bit}\mskip1.5mu]}
        \ar[d]^{\ensuremath{\Varid{id}\mathbin{+}(\mathsf{fmap}\;(v_3 ))\times\Varid{id}}}
\\
&
    \ensuremath{\mathrm{1}\mathbin{+}\Conid{M}\;\Conid{Bit}\times\Conid{M}\;[\mskip1.5mu \Conid{Bit}\mskip1.5mu]}
            \ar[uuul]^{\ensuremath{\alt{\Varid{return}\comp \Varid{nil}}{g_1 }}}
}
\end{eqnarray*}

Definição de \ensuremath{\Varid{propagate3}}:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{propagate3}\mathbin{::}(\Conid{Monad}\;\Varid{m})\Rightarrow (\Conid{Bit3}\to \Varid{m}\;\Conid{Bit3})\to [\mskip1.5mu \Conid{Bit}\mskip1.5mu]\to \Varid{m}\;[\mskip1.5mu \Conid{Bit}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{propagate3}\;\Varid{f}\mathrel{=}\cataList{\Varid{g}\;\Varid{f}}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{g}\;\Varid{f}\mathrel{=}\alt{\Varid{return}\comp \Varid{nil}}{g_2 \;\Varid{f}}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}g_2 \;\Varid{f}\;(\Varid{a},\Varid{b})\mathrel{=}\mathbf{do}\;\{\mskip1.5mu \Varid{x}\leftarrow ((\mathsf{fmap}\;v_3 )\comp \Varid{f})\;(\Varid{a},\Varid{a},\Varid{a});\Varid{y}\leftarrow \Varid{b};\Varid{return}\;(\Varid{x}\mathbin{:}\Varid{y})\mskip1.5mu\}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
A função \ensuremath{\Varid{bflip3}}, a programar a seguir, deverá estender \ensuremath{\Varid{bflip}} aos três bits da entrada:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{bflip3}\mathbin{::}\Conid{Bit3}\to \fun{Dist}\;\Conid{Bit3}{}\<[E]%
\\
\>[B]{}\Varid{bflip3}\;(\Varid{a},\Varid{b},\Varid{c})\mathrel{=}\mathbf{do}\;\{\mskip1.5mu \Varid{x}\leftarrow \Varid{bflip}\;\Varid{a};\Varid{y}\leftarrow \Varid{bflip}\;\Varid{b};\Varid{z}\leftarrow \Varid{bflip}\;\Varid{c};\Varid{return}\;(\Varid{x},\Varid{y},\Varid{z})\mskip1.5mu\}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

%----------------- Índice remissivo (exige makeindex) -------------------------%

\printindex

%----------------- Bibliografia (exige bibtex) --------------------------------%

\bibliographystyle{plain}
\bibliography{cp2122t}

%----------------- Fim do documento -------------------------------------------%
\end{document}
